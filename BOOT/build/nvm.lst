ARM GAS  /tmp/ccjh2AG5.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"nvm.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "Core/Src/BLT/nvm.c"
  20              		.section	.text.NvmInit,"ax",%progbits
  21              		.align	1
  22              		.global	NvmInit
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	NvmInit:
  28              	.LFB0:
   1:Core/Src/BLT/nvm.c **** /************************************************************************************//**
   2:Core/Src/BLT/nvm.c **** * \file         Source/ARMCM4_STM32F3/nvm.c
   3:Core/Src/BLT/nvm.c **** * \brief        Bootloader non-volatile memory driver source file.
   4:Core/Src/BLT/nvm.c **** * \ingroup      Target_ARMCM4_STM32F3
   5:Core/Src/BLT/nvm.c **** * \internal
   6:Core/Src/BLT/nvm.c **** *----------------------------------------------------------------------------------------
   7:Core/Src/BLT/nvm.c **** *                          C O P Y R I G H T
   8:Core/Src/BLT/nvm.c **** *----------------------------------------------------------------------------------------
   9:Core/Src/BLT/nvm.c **** *   Copyright (c) 2016  by Feaser    http://www.feaser.com    All rights reserved
  10:Core/Src/BLT/nvm.c **** *
  11:Core/Src/BLT/nvm.c **** *----------------------------------------------------------------------------------------
  12:Core/Src/BLT/nvm.c **** *                            L I C E N S E
  13:Core/Src/BLT/nvm.c **** *----------------------------------------------------------------------------------------
  14:Core/Src/BLT/nvm.c **** * This file is part of OpenBLT. OpenBLT is free software: you can redistribute it and/or
  15:Core/Src/BLT/nvm.c **** * modify it under the terms of the GNU General Public License as published by the Free
  16:Core/Src/BLT/nvm.c **** * Software Foundation, either version 3 of the License, or (at your option) any later
  17:Core/Src/BLT/nvm.c **** * version.
  18:Core/Src/BLT/nvm.c **** *
  19:Core/Src/BLT/nvm.c **** * OpenBLT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  20:Core/Src/BLT/nvm.c **** * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  21:Core/Src/BLT/nvm.c **** * PURPOSE. See the GNU General Public License for more details.
  22:Core/Src/BLT/nvm.c **** *
  23:Core/Src/BLT/nvm.c **** * You have received a copy of the GNU General Public License along with OpenBLT. It
  24:Core/Src/BLT/nvm.c **** * should be located in ".\Doc\license.html". If not, contact Feaser to obtain a copy.
  25:Core/Src/BLT/nvm.c **** *
  26:Core/Src/BLT/nvm.c **** * \endinternal
  27:Core/Src/BLT/nvm.c **** ****************************************************************************************/
  28:Core/Src/BLT/nvm.c **** 
  29:Core/Src/BLT/nvm.c **** /****************************************************************************************
  30:Core/Src/BLT/nvm.c **** * Include files
ARM GAS  /tmp/ccjh2AG5.s 			page 2


  31:Core/Src/BLT/nvm.c **** ****************************************************************************************/
  32:Core/Src/BLT/nvm.c **** #include "BLT/boot.h"                                /* bootloader generic header          */
  33:Core/Src/BLT/nvm.c **** #include "BLT/flash.h"
  34:Core/Src/BLT/nvm.c **** 
  35:Core/Src/BLT/nvm.c **** 
  36:Core/Src/BLT/nvm.c **** /****************************************************************************************
  37:Core/Src/BLT/nvm.c **** * Hook functions
  38:Core/Src/BLT/nvm.c **** ****************************************************************************************/
  39:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
  40:Core/Src/BLT/nvm.c **** extern void      NvmInitHook(void);
  41:Core/Src/BLT/nvm.c **** extern void      NvmReinitHook(void);
  42:Core/Src/BLT/nvm.c **** extern blt_int8u NvmWriteHook(blt_addr addr, blt_int32u len, blt_int8u *data);
  43:Core/Src/BLT/nvm.c **** extern blt_int8u NvmEraseHook(blt_addr addr, blt_int32u len);
  44:Core/Src/BLT/nvm.c **** extern blt_bool  NvmDoneHook(void);
  45:Core/Src/BLT/nvm.c **** #endif
  46:Core/Src/BLT/nvm.c **** 
  47:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_CHECKSUM_HOOKS_ENABLE > 0)
  48:Core/Src/BLT/nvm.c **** extern blt_bool  NvmWriteChecksumHook(void);
  49:Core/Src/BLT/nvm.c **** extern blt_bool  NvmVerifyChecksumHook(void);
  50:Core/Src/BLT/nvm.c **** #endif
  51:Core/Src/BLT/nvm.c **** 
  52:Core/Src/BLT/nvm.c **** 
  53:Core/Src/BLT/nvm.c **** /************************************************************************************//**
  54:Core/Src/BLT/nvm.c **** ** \brief     Initializes the NVM driver.
  55:Core/Src/BLT/nvm.c **** ** \return    none.
  56:Core/Src/BLT/nvm.c **** **
  57:Core/Src/BLT/nvm.c **** ****************************************************************************************/
  58:Core/Src/BLT/nvm.c **** void NvmInit(void)
  59:Core/Src/BLT/nvm.c **** {
  29              		.loc 1 59 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 08B5     		push	{r3, lr}
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 3, -8
  36              		.cfi_offset 14, -4
  60:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
  61:Core/Src/BLT/nvm.c ****   /* give the application a chance to initialize a driver for operating on NVM
  62:Core/Src/BLT/nvm.c ****    * that is not by default supported by this driver.
  63:Core/Src/BLT/nvm.c ****    */
  64:Core/Src/BLT/nvm.c ****   NvmInitHook();
  65:Core/Src/BLT/nvm.c **** #endif
  66:Core/Src/BLT/nvm.c **** 
  67:Core/Src/BLT/nvm.c ****   /* init the internal driver */
  68:Core/Src/BLT/nvm.c ****   FlashInit();
  37              		.loc 1 68 3 view .LVU1
  38 0002 FFF7FEFF 		bl	FlashInit
  39              	.LVL0:
  69:Core/Src/BLT/nvm.c **** } /*** end of NvmInit ***/
  40              		.loc 1 69 1 is_stmt 0 view .LVU2
  41 0006 08BD     		pop	{r3, pc}
  42              		.cfi_endproc
  43              	.LFE0:
  45              		.section	.text.NvmReinit,"ax",%progbits
  46              		.align	1
  47              		.global	NvmReinit
ARM GAS  /tmp/ccjh2AG5.s 			page 3


  48              		.syntax unified
  49              		.thumb
  50              		.thumb_func
  52              	NvmReinit:
  53              	.LFB1:
  70:Core/Src/BLT/nvm.c **** 
  71:Core/Src/BLT/nvm.c **** 
  72:Core/Src/BLT/nvm.c **** /************************************************************************************//**
  73:Core/Src/BLT/nvm.c **** ** \brief     Reinitializes the NVM driver. This function is called at the start of each
  74:Core/Src/BLT/nvm.c **** **            firmware update as opposed to NvmInit, which is only called once during
  75:Core/Src/BLT/nvm.c **** **            power on.
  76:Core/Src/BLT/nvm.c **** ** \return    none.
  77:Core/Src/BLT/nvm.c **** **
  78:Core/Src/BLT/nvm.c **** ****************************************************************************************/
  79:Core/Src/BLT/nvm.c **** void NvmReinit(void)
  80:Core/Src/BLT/nvm.c **** {
  54              		.loc 1 80 1 is_stmt 1 view -0
  55              		.cfi_startproc
  56              		@ args = 0, pretend = 0, frame = 0
  57              		@ frame_needed = 0, uses_anonymous_args = 0
  58 0000 08B5     		push	{r3, lr}
  59              		.cfi_def_cfa_offset 8
  60              		.cfi_offset 3, -8
  61              		.cfi_offset 14, -4
  81:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
  82:Core/Src/BLT/nvm.c ****   /* give the application a chance to re-initialize a driver for operating on NVM
  83:Core/Src/BLT/nvm.c ****    * that is not by default supported by this driver.
  84:Core/Src/BLT/nvm.c ****    */
  85:Core/Src/BLT/nvm.c ****   NvmReinitHook();
  86:Core/Src/BLT/nvm.c **** #endif
  87:Core/Src/BLT/nvm.c **** 
  88:Core/Src/BLT/nvm.c ****   /* reinitialize the internal driver */
  89:Core/Src/BLT/nvm.c ****   FlashReinit();
  62              		.loc 1 89 3 view .LVU4
  63 0002 FFF7FEFF 		bl	FlashReinit
  64              	.LVL1:
  90:Core/Src/BLT/nvm.c **** } /*** end of NvmReinit ***/
  65              		.loc 1 90 1 is_stmt 0 view .LVU5
  66 0006 08BD     		pop	{r3, pc}
  67              		.cfi_endproc
  68              	.LFE1:
  70              		.section	.text.NvmWrite,"ax",%progbits
  71              		.align	1
  72              		.global	NvmWrite
  73              		.syntax unified
  74              		.thumb
  75              		.thumb_func
  77              	NvmWrite:
  78              	.LVL2:
  79              	.LFB2:
  91:Core/Src/BLT/nvm.c **** 
  92:Core/Src/BLT/nvm.c **** 
  93:Core/Src/BLT/nvm.c **** /************************************************************************************//**
  94:Core/Src/BLT/nvm.c **** ** \brief     Programs the non-volatile memory.
  95:Core/Src/BLT/nvm.c **** ** \param     addr Start address.
  96:Core/Src/BLT/nvm.c **** ** \param     len  Length in bytes.
  97:Core/Src/BLT/nvm.c **** ** \param     data Pointer to the data buffer.
ARM GAS  /tmp/ccjh2AG5.s 			page 4


  98:Core/Src/BLT/nvm.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
  99:Core/Src/BLT/nvm.c **** **
 100:Core/Src/BLT/nvm.c **** ****************************************************************************************/
 101:Core/Src/BLT/nvm.c **** blt_bool NvmWrite(blt_addr addr, blt_int32u len, blt_int8u *data)
 102:Core/Src/BLT/nvm.c **** {
  80              		.loc 1 102 1 is_stmt 1 view -0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  84              		.loc 1 102 1 is_stmt 0 view .LVU7
  85 0000 08B5     		push	{r3, lr}
  86              		.cfi_def_cfa_offset 8
  87              		.cfi_offset 3, -8
  88              		.cfi_offset 14, -4
 103:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
 104:Core/Src/BLT/nvm.c ****   blt_int8u result = BLT_NVM_NOT_IN_RANGE;
 105:Core/Src/BLT/nvm.c **** #endif
 106:Core/Src/BLT/nvm.c **** 
 107:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
 108:Core/Src/BLT/nvm.c ****   /* give the application a chance to operate on memory that is not by default supported
 109:Core/Src/BLT/nvm.c ****    * by this driver.
 110:Core/Src/BLT/nvm.c ****    */
 111:Core/Src/BLT/nvm.c ****   result = NvmWriteHook(addr, len, data);
 112:Core/Src/BLT/nvm.c **** 
 113:Core/Src/BLT/nvm.c ****   /* process the return code */
 114:Core/Src/BLT/nvm.c ****   if (result == BLT_NVM_OKAY)
 115:Core/Src/BLT/nvm.c ****   {
 116:Core/Src/BLT/nvm.c ****     /* data was within range of the additionally supported memory and succesfully
 117:Core/Src/BLT/nvm.c ****      * programmed, so we are all done.
 118:Core/Src/BLT/nvm.c ****      */
 119:Core/Src/BLT/nvm.c ****     return BLT_TRUE;
 120:Core/Src/BLT/nvm.c ****   }
 121:Core/Src/BLT/nvm.c ****   else if (result == BLT_NVM_ERROR)
 122:Core/Src/BLT/nvm.c ****   {
 123:Core/Src/BLT/nvm.c ****     /* data was within range of the additionally supported memory and attempted to be
 124:Core/Src/BLT/nvm.c ****      * programmed, but an error occurred, so we can't continue.
 125:Core/Src/BLT/nvm.c ****      */
 126:Core/Src/BLT/nvm.c ****     return BLT_FALSE;
 127:Core/Src/BLT/nvm.c ****   }
 128:Core/Src/BLT/nvm.c **** #endif
 129:Core/Src/BLT/nvm.c **** 
 130:Core/Src/BLT/nvm.c ****   /* still here so the internal driver should try and perform the program operation */
 131:Core/Src/BLT/nvm.c ****   return FlashWrite(addr, len, data);
  89              		.loc 1 131 3 is_stmt 1 view .LVU8
  90              		.loc 1 131 10 is_stmt 0 view .LVU9
  91 0002 FFF7FEFF 		bl	FlashWrite
  92              	.LVL3:
 132:Core/Src/BLT/nvm.c **** } /*** end of NvmWrite ***/
  93              		.loc 1 132 1 view .LVU10
  94 0006 08BD     		pop	{r3, pc}
  95              		.cfi_endproc
  96              	.LFE2:
  98              		.section	.text.NvmErase,"ax",%progbits
  99              		.align	1
 100              		.global	NvmErase
 101              		.syntax unified
 102              		.thumb
ARM GAS  /tmp/ccjh2AG5.s 			page 5


 103              		.thumb_func
 105              	NvmErase:
 106              	.LVL4:
 107              	.LFB3:
 133:Core/Src/BLT/nvm.c **** 
 134:Core/Src/BLT/nvm.c **** 
 135:Core/Src/BLT/nvm.c **** /************************************************************************************//**
 136:Core/Src/BLT/nvm.c **** ** \brief     Erases the non-volatile memory.
 137:Core/Src/BLT/nvm.c **** ** \param     addr Start address.
 138:Core/Src/BLT/nvm.c **** ** \param     len  Length in bytes.
 139:Core/Src/BLT/nvm.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
 140:Core/Src/BLT/nvm.c **** **
 141:Core/Src/BLT/nvm.c **** ****************************************************************************************/
 142:Core/Src/BLT/nvm.c **** blt_bool NvmErase(blt_addr addr, blt_int32u len)
 143:Core/Src/BLT/nvm.c **** {
 108              		.loc 1 143 1 is_stmt 1 view -0
 109              		.cfi_startproc
 110              		@ args = 0, pretend = 0, frame = 0
 111              		@ frame_needed = 0, uses_anonymous_args = 0
 112              		.loc 1 143 1 is_stmt 0 view .LVU12
 113 0000 08B5     		push	{r3, lr}
 114              		.cfi_def_cfa_offset 8
 115              		.cfi_offset 3, -8
 116              		.cfi_offset 14, -4
 144:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
 145:Core/Src/BLT/nvm.c ****   blt_int8u result = BLT_NVM_NOT_IN_RANGE;
 146:Core/Src/BLT/nvm.c **** #endif
 147:Core/Src/BLT/nvm.c **** 
 148:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
 149:Core/Src/BLT/nvm.c ****   /* give the application a chance to operate on memory that is not by default supported
 150:Core/Src/BLT/nvm.c ****    * by this driver.
 151:Core/Src/BLT/nvm.c ****    */
 152:Core/Src/BLT/nvm.c ****   result = NvmEraseHook(addr, len);
 153:Core/Src/BLT/nvm.c **** 
 154:Core/Src/BLT/nvm.c ****   /* process the return code */
 155:Core/Src/BLT/nvm.c ****   if (result == BLT_NVM_OKAY)
 156:Core/Src/BLT/nvm.c ****   {
 157:Core/Src/BLT/nvm.c ****     /* address was within range of the additionally supported memory and succesfully
 158:Core/Src/BLT/nvm.c ****      * erased, so we are all done.
 159:Core/Src/BLT/nvm.c ****      */
 160:Core/Src/BLT/nvm.c ****     return BLT_TRUE;
 161:Core/Src/BLT/nvm.c ****   }
 162:Core/Src/BLT/nvm.c ****   else if (result == BLT_NVM_ERROR)
 163:Core/Src/BLT/nvm.c ****   {
 164:Core/Src/BLT/nvm.c ****     /* address was within range of the additionally supported memory and attempted to be
 165:Core/Src/BLT/nvm.c ****      * erased, but an error occurred, so we can't continue.
 166:Core/Src/BLT/nvm.c ****      */
 167:Core/Src/BLT/nvm.c ****     return BLT_FALSE;
 168:Core/Src/BLT/nvm.c ****   }
 169:Core/Src/BLT/nvm.c **** #endif
 170:Core/Src/BLT/nvm.c **** 
 171:Core/Src/BLT/nvm.c ****   /* still here so the internal driver should try and perform the erase operation */
 172:Core/Src/BLT/nvm.c ****   return FlashErase(addr, len);
 117              		.loc 1 172 3 is_stmt 1 view .LVU13
 118              		.loc 1 172 10 is_stmt 0 view .LVU14
 119 0002 FFF7FEFF 		bl	FlashErase
 120              	.LVL5:
ARM GAS  /tmp/ccjh2AG5.s 			page 6


 173:Core/Src/BLT/nvm.c **** } /*** end of NvmErase ***/
 121              		.loc 1 173 1 view .LVU15
 122 0006 08BD     		pop	{r3, pc}
 123              		.cfi_endproc
 124              	.LFE3:
 126              		.section	.text.NvmVerifyChecksum,"ax",%progbits
 127              		.align	1
 128              		.global	NvmVerifyChecksum
 129              		.syntax unified
 130              		.thumb
 131              		.thumb_func
 133              	NvmVerifyChecksum:
 134              	.LFB4:
 174:Core/Src/BLT/nvm.c **** 
 175:Core/Src/BLT/nvm.c **** 
 176:Core/Src/BLT/nvm.c **** /************************************************************************************//**
 177:Core/Src/BLT/nvm.c **** ** \brief     Verifies the checksum, which indicates that a valid user program is
 178:Core/Src/BLT/nvm.c **** **            present and can be started.
 179:Core/Src/BLT/nvm.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
 180:Core/Src/BLT/nvm.c **** **
 181:Core/Src/BLT/nvm.c **** ****************************************************************************************/
 182:Core/Src/BLT/nvm.c **** blt_bool NvmVerifyChecksum(void)
 183:Core/Src/BLT/nvm.c **** {
 135              		.loc 1 183 1 is_stmt 1 view -0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139 0000 08B5     		push	{r3, lr}
 140              		.cfi_def_cfa_offset 8
 141              		.cfi_offset 3, -8
 142              		.cfi_offset 14, -4
 184:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_CHECKSUM_HOOKS_ENABLE > 0)
 185:Core/Src/BLT/nvm.c ****   /* check checksum using the application specific method. */
 186:Core/Src/BLT/nvm.c ****   return NvmVerifyChecksumHook();
 187:Core/Src/BLT/nvm.c **** #else
 188:Core/Src/BLT/nvm.c ****   /* check checksum using the interally supported method. */
 189:Core/Src/BLT/nvm.c ****   return FlashVerifyChecksum();
 143              		.loc 1 189 3 view .LVU17
 144              		.loc 1 189 10 is_stmt 0 view .LVU18
 145 0002 FFF7FEFF 		bl	FlashVerifyChecksum
 146              	.LVL6:
 190:Core/Src/BLT/nvm.c **** #endif
 191:Core/Src/BLT/nvm.c **** } /*** end of NvmVerifyChecksum ***/
 147              		.loc 1 191 1 view .LVU19
 148 0006 08BD     		pop	{r3, pc}
 149              		.cfi_endproc
 150              	.LFE4:
 152              		.section	.text.NvmGetUserProgBaseAddress,"ax",%progbits
 153              		.align	1
 154              		.global	NvmGetUserProgBaseAddress
 155              		.syntax unified
 156              		.thumb
 157              		.thumb_func
 159              	NvmGetUserProgBaseAddress:
 160              	.LFB5:
 192:Core/Src/BLT/nvm.c **** 
 193:Core/Src/BLT/nvm.c **** 
ARM GAS  /tmp/ccjh2AG5.s 			page 7


 194:Core/Src/BLT/nvm.c **** /************************************************************************************//**
 195:Core/Src/BLT/nvm.c **** ** \brief     Obtains the base address of the non-volatile memory available to the user
 196:Core/Src/BLT/nvm.c **** **            program. This is typically that start of the vector table.
 197:Core/Src/BLT/nvm.c **** ** \return    Base address.
 198:Core/Src/BLT/nvm.c **** **
 199:Core/Src/BLT/nvm.c **** ****************************************************************************************/
 200:Core/Src/BLT/nvm.c **** blt_addr NvmGetUserProgBaseAddress(void)
 201:Core/Src/BLT/nvm.c **** {
 161              		.loc 1 201 1 is_stmt 1 view -0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 0
 164              		@ frame_needed = 0, uses_anonymous_args = 0
 165 0000 08B5     		push	{r3, lr}
 166              		.cfi_def_cfa_offset 8
 167              		.cfi_offset 3, -8
 168              		.cfi_offset 14, -4
 202:Core/Src/BLT/nvm.c ****   return FlashGetUserProgBaseAddress();
 169              		.loc 1 202 3 view .LVU21
 170              		.loc 1 202 10 is_stmt 0 view .LVU22
 171 0002 FFF7FEFF 		bl	FlashGetUserProgBaseAddress
 172              	.LVL7:
 203:Core/Src/BLT/nvm.c **** } /*** end of NvmGetUserProgBaseAddress ***/
 173              		.loc 1 203 1 view .LVU23
 174 0006 08BD     		pop	{r3, pc}
 175              		.cfi_endproc
 176              	.LFE5:
 178              		.section	.text.NvmDone,"ax",%progbits
 179              		.align	1
 180              		.global	NvmDone
 181              		.syntax unified
 182              		.thumb
 183              		.thumb_func
 185              	NvmDone:
 186              	.LFB6:
 204:Core/Src/BLT/nvm.c **** 
 205:Core/Src/BLT/nvm.c **** 
 206:Core/Src/BLT/nvm.c **** /************************************************************************************//**
 207:Core/Src/BLT/nvm.c **** ** \brief     Once all erase and programming operations are completed, this
 208:Core/Src/BLT/nvm.c **** **            function is called, so at the end of the programming session and
 209:Core/Src/BLT/nvm.c **** **            right before a software reset is performed. It is used to calculate
 210:Core/Src/BLT/nvm.c **** **            a checksum and program this into flash. This checksum is later used
 211:Core/Src/BLT/nvm.c **** **            to determine if a valid user program is present in flash.
 212:Core/Src/BLT/nvm.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
 213:Core/Src/BLT/nvm.c **** **
 214:Core/Src/BLT/nvm.c **** ****************************************************************************************/
 215:Core/Src/BLT/nvm.c **** blt_bool NvmDone(void)
 216:Core/Src/BLT/nvm.c **** {
 187              		.loc 1 216 1 is_stmt 1 view -0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191 0000 08B5     		push	{r3, lr}
 192              		.cfi_def_cfa_offset 8
 193              		.cfi_offset 3, -8
 194              		.cfi_offset 14, -4
 217:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_HOOKS_ENABLE > 0)
 218:Core/Src/BLT/nvm.c ****   /* give the application's NVM driver a chance to finish up */
ARM GAS  /tmp/ccjh2AG5.s 			page 8


 219:Core/Src/BLT/nvm.c ****   if (NvmDoneHook() == BLT_FALSE)
 220:Core/Src/BLT/nvm.c ****   {
 221:Core/Src/BLT/nvm.c ****     /* error so no need to continue */
 222:Core/Src/BLT/nvm.c ****     return BLT_FALSE;
 223:Core/Src/BLT/nvm.c ****   }
 224:Core/Src/BLT/nvm.c **** #endif
 225:Core/Src/BLT/nvm.c **** 
 226:Core/Src/BLT/nvm.c **** #if (BOOT_NVM_CHECKSUM_HOOKS_ENABLE > 0)
 227:Core/Src/BLT/nvm.c ****   /* compute and write checksum, using the application specific method. */
 228:Core/Src/BLT/nvm.c ****   if (NvmWriteChecksumHook() == BLT_FALSE)
 229:Core/Src/BLT/nvm.c ****   {
 230:Core/Src/BLT/nvm.c ****     return BLT_FALSE;
 231:Core/Src/BLT/nvm.c ****   }
 232:Core/Src/BLT/nvm.c **** #else
 233:Core/Src/BLT/nvm.c ****   /* compute and write checksum, which is programmed by the internal driver. */
 234:Core/Src/BLT/nvm.c ****   if (FlashWriteChecksum() == BLT_FALSE)
 195              		.loc 1 234 3 view .LVU25
 196              		.loc 1 234 7 is_stmt 0 view .LVU26
 197 0002 FFF7FEFF 		bl	FlashWriteChecksum
 198              	.LVL8:
 199              		.loc 1 234 6 view .LVU27
 200 0006 00B9     		cbnz	r0, .L16
 201              	.L14:
 235:Core/Src/BLT/nvm.c ****   {
 236:Core/Src/BLT/nvm.c ****     return BLT_FALSE;
 237:Core/Src/BLT/nvm.c ****   }
 238:Core/Src/BLT/nvm.c **** #endif
 239:Core/Src/BLT/nvm.c **** 
 240:Core/Src/BLT/nvm.c ****   /* finish up internal driver operations */
 241:Core/Src/BLT/nvm.c ****   return FlashDone();
 242:Core/Src/BLT/nvm.c **** } /*** end of NvmDone ***/
 202              		.loc 1 242 1 view .LVU28
 203 0008 08BD     		pop	{r3, pc}
 204              	.L16:
 241:Core/Src/BLT/nvm.c **** } /*** end of NvmDone ***/
 205              		.loc 1 241 3 is_stmt 1 view .LVU29
 241:Core/Src/BLT/nvm.c **** } /*** end of NvmDone ***/
 206              		.loc 1 241 10 is_stmt 0 view .LVU30
 207 000a FFF7FEFF 		bl	FlashDone
 208              	.LVL9:
 209 000e FBE7     		b	.L14
 210              		.cfi_endproc
 211              	.LFE6:
 213              		.text
 214              	.Letext0:
 215              		.file 2 "Core/Inc/BLT/types.h"
 216              		.file 3 "Core/Inc/BLT/flash.h"
ARM GAS  /tmp/ccjh2AG5.s 			page 9


DEFINED SYMBOLS
                            *ABS*:0000000000000000 nvm.c
     /tmp/ccjh2AG5.s:21     .text.NvmInit:0000000000000000 $t
     /tmp/ccjh2AG5.s:27     .text.NvmInit:0000000000000000 NvmInit
     /tmp/ccjh2AG5.s:46     .text.NvmReinit:0000000000000000 $t
     /tmp/ccjh2AG5.s:52     .text.NvmReinit:0000000000000000 NvmReinit
     /tmp/ccjh2AG5.s:71     .text.NvmWrite:0000000000000000 $t
     /tmp/ccjh2AG5.s:77     .text.NvmWrite:0000000000000000 NvmWrite
     /tmp/ccjh2AG5.s:99     .text.NvmErase:0000000000000000 $t
     /tmp/ccjh2AG5.s:105    .text.NvmErase:0000000000000000 NvmErase
     /tmp/ccjh2AG5.s:127    .text.NvmVerifyChecksum:0000000000000000 $t
     /tmp/ccjh2AG5.s:133    .text.NvmVerifyChecksum:0000000000000000 NvmVerifyChecksum
     /tmp/ccjh2AG5.s:153    .text.NvmGetUserProgBaseAddress:0000000000000000 $t
     /tmp/ccjh2AG5.s:159    .text.NvmGetUserProgBaseAddress:0000000000000000 NvmGetUserProgBaseAddress
     /tmp/ccjh2AG5.s:179    .text.NvmDone:0000000000000000 $t
     /tmp/ccjh2AG5.s:185    .text.NvmDone:0000000000000000 NvmDone

UNDEFINED SYMBOLS
FlashInit
FlashReinit
FlashWrite
FlashErase
FlashVerifyChecksum
FlashGetUserProgBaseAddress
FlashWriteChecksum
FlashDone
